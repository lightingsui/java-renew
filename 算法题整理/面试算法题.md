# 面试算法题
## 链表
### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**哈希表实现**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set = new HashSet<>();

        while (head != null) {
            if(set.contains(head)) {
                return true;
            }
            set.add(head);
            head = head.next;
        }
        return false;
    }
}
```

**快慢指针**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null) {
            return false;
        }

        ListNode fast = head.next;
        ListNode slow = head;
        
        while(fast != slow) {
            if(fast == null || fast.next == null) {
                return false;
            }
            
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**哈希表**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;
        
        Set<ListNode> set = new HashSet<>();

        while (head != null) {
            if(set.contains(head)) {
                return head;
            }

            set.add(head);
            head = head.next;
        }

        return null;
    }
}
```

**快慢指针**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null) return null;

        ListNode fast = head;
        ListNode slow = head;

        while(true) {
            if(fast == null || fast.next == null) {
                return null;
            }

            fast = fast.next.next;
            slow = slow.next;

            if(slow == fast) break;
        }

        fast = head;

        while(fast != slow) {
            slow = slow.next;
            fast = fast.next;
        }

        return fast;
    }
}
```

### [面试题 02.02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

**hash表**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode p = head;

        for (int i = 0; i < k; i++) {
            p = p.next;
        }
        
        while (p != null) {
            p = p.next;
            head = head.next;
        }
        
        return head.val;
    }
}
```

**快慢指针**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode p = head;

        for (int i = 0; i < k; i++) {
            p = p.next;
        }

        while (p.next != null) {
            p = p.next;
            head = head.next;
        }

        return head.val;
    }
}
```

### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

**快慢指针**

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;

        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        slow = 0;

        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
```

**hash表**

```java
class Solution {
    public int findDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();

        for (int i = 0; i < nums.length; i++) {
            if(set.contains(nums[i])) {
                return nums[i];
            }
            set.add(nums[i]);
        }
        return -1;
    }
}
```

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);

        ListNode pre = head;

        int carry = 0;

        while (l1 != null || l2 != null) {
            int l1Value = l1 == null ? 0 : l1.val;
            int l2Value = l2 == null ? 0 : l2.val;

            int sum = l1Value + l2Value + carry;

            carry = sum / 10;

            sum = sum - carry * 10;

            pre.next = new ListNode(sum);
            pre = pre.next;
            
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        
        if(carry > 0) {
            pre.next = new ListNode(carry);
        }
        
        return head.next;
    }
}
```

### [面试题24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

**双指针**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) return null;
        ListNode pre = head;
        ListNode cur = null;

        while(pre != null) {
            ListNode temp = pre.next;
            pre.next = cur;
            
            cur = pre;
            
            pre = temp;
        }
        
        return cur;
    }
}
```

### [面试题25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null && l2 == null) return null;

        ListNode listNode = new ListNode(-Integer.MAX_VALUE);
        ListNode temp = listNode;

        while (l1 != null || l2 != null) {
            if (l1 != null && l2 != null) {

                if (l1.val >= l2.val) {
                    temp.next = new ListNode(l2.val);
                    l2 = l2.next;
                } else {
                    temp.next = new ListNode(l1.val);
                    l1 = l1.next;
                }
            } else if (l1 != null) {
                temp.next = new ListNode(l1.val);
                l1 = l1.next;
            } else {
                temp.next = new ListNode(l2.val);
                l2 = l2.next;
            }
            temp = temp.next;
        }

        return listNode.next;
    }
}
```

### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode last = head;
        ListNode first = head;
        ListNode temp = null;

        for (int i = 0; i < n; i++) {
            last = last.next;
        }

        if(last == null) return head = head.next;

        while(true) {
            if(last.next == null) {
                temp = first.next.next;
                first.next = temp;

                break;
            }
            last = last.next;
            first = first.next;
        }

        return head;
    }
}
```

## 字符串

### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0) {
            return "";
        }

        String longStr = strs[0];

        for (int i = 1; i < strs.length; i++) {
            int j = 0;
            for (; j < longStr.length() && j < strs[i].length(); j++) {
                if(longStr.charAt(j) != strs[i].charAt(j)) {
                    break;
                }
            }

            longStr = longStr.substring(0, j);

            if("".equals(longStr)) return "";
        }

        return longStr;
    }
}
```

## 数组

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int maxVal = nums[0];

        for(int x : nums) {
            pre = Integer.max(pre + x, x);
            maxVal = Integer.max(pre, maxVal);
        }

        return maxVal;
    }
}
```

## 二叉树

### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    public String cycleSerialize(TreeNode root, String str) {
        if(root == null) return str + "None,";

        str += root.val + ",";
        str = cycleSerialize(root.left, str);
        str = cycleSerialize(root.right, str);

        return str;
    }

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        return cycleSerialize(root, "");
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        return cycleDeserialize(new ArrayList<>(Arrays.asList(data.split(","))));
    }

    public TreeNode cycleDeserialize(List<String> list) {
        if("None".equals(list.get(0))) {
            list.remove(0);
            return null;
        }

        TreeNode treeNode = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        treeNode.left = cycleDeserialize(list);
        treeNode.right = cycleDeserialize(list);

        return treeNode;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## 其它

### [1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)

```java
class Solution {
    public int maxScoreSightseeingPair(int[] A) {
        int ans = 0;
        int mx = A[0] + 0;

        for (int i = 1; i < A.length; i++) {
            ans = Math.max(ans, mx + A[i] - i);
            
            // 算出前面最大的a[i] + i
            mx = Math.max(mx, A[i] + i);
        }
        
        return ans;
    }
}
```

